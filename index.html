<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>SmartSwitch â€” Final UI</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
<link rel="icon" type="image/x-icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ’¡</text></svg>">
<style>
:root{
  --bg: linear-gradient(180deg,#0f1030 0%, #0b1538 100%);
  --card: rgba(255,255,255,0.03);
  --glass: rgba(255,255,255,0.09);
  --accent1: #7fb1ff;
  --accent2: #9a6bff;
  --muted: rgba(255,255,255,0.96);
  --muted2: rgba(255,255,255,0.55);
  --nav-height:92px;
  --max-width:980px;
  --soft-shadow: 0 10px 30px rgba(13,18,46,0.55);
  --blur: 8px;
}
*{box-sizing:border-box;-webkit-tap-highlight-color:transparent;outline:none}
html,body{height:100%;margin:0;background:var(--bg);color:var(--muted);font-family:Inter,system-ui,Roboto,Arial}
body{padding:0;margin:0}
#main{max-width:var(--max-width);margin:14px auto;padding:12px;padding-bottom:calc(var(--nav-height) + 32px)}

/* Header */
.header{display:flex;justify-content:space-between;align-items:center;gap:12px;margin-bottom:12px}
.brand{display:flex;align-items:center;gap:12px}
.mark{width:52px;height:52px;border-radius:12px;background:linear-gradient(135deg,var(--accent1),var(--accent2));display:flex;align-items:center;justify-content:center;overflow:hidden;box-shadow:0 8px 30px rgba(122,57,255,0.06)}
.mark img{width:100%;height:100%;object-fit:cover}
.brand-title{font-size:18px;font-weight:700}
.brand-sub{font-size:12px;color:var(--muted2)}

/* WiFi round icon */
.wifi-btn{width:48px;height:48px;border-radius:12px;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.08);display:flex;align-items:center;justify-content:center;position:relative;cursor:pointer;transition:all .18s}
.wifi-btn.connected{background:linear-gradient(135deg,#b7f7d4,#7df2a3);box-shadow:0 12px 32px rgba(125,242,163,0.12)}
.wifi-btn.disconnected{background:linear-gradient(135deg,#ff9a9a,#ff5c5c);box-shadow:0 12px 32px rgba(255,92,92,0.12)}
.wifi-arc{position:absolute;border-radius:50%;border-top:3px solid rgba(255,255,255,0.95);border-left:3px solid transparent;border-right:3px solid transparent;border-bottom:3px solid transparent;opacity:0.95;animation: wifiPulse 2s infinite ease-in-out}
.wifi-arc:nth-child(2) { animation-delay: 0.2s; }
.wifi-arc:nth-child(3) { animation-delay: 0.4s; }
.wifi-a1{width:14px;height:14px;bottom:8px}
.wifi-a2{width:24px;height:24px;bottom:3px}
.wifi-a3{width:34px;height:34px;bottom:-3px}
.wifi-dot{width:7px;height:7px;background:white;border-radius:50%;position:absolute;bottom:15px}
.wifi-btn.connected .wifi-arc, .wifi-btn.connected .wifi-dot{animation:pulse 1.8s infinite ease-in-out}
@keyframes pulse{0%{opacity:1;transform:scale(1)}50%{opacity:.78;transform:scale(1.04)}100%{opacity:1;transform:scale(1)}}

/* Instagram-like Logo Animation */
@keyframes logoEntrance {
  0% {
    transform: scale(0.2);
    opacity: 0;
  }
  50% {
    transform: scale(1.1);
    opacity: 1;
  }
  70% {
    transform: scale(0.9);
  }
  100% {
    transform: scale(1);
    opacity: 1;
  }
}

@keyframes wavePulse {
  0% {
    transform: translate(-50%, -50%) scale(1);
    opacity: 1;
  }
  100% {
    transform: translate(-50%, -50%) scale(1.5);
    opacity: 0;
  }
}

@keyframes buttonPulse {
  0% {
    transform: scale(1);
    box-shadow: 0 8px 30px rgba(0,0,0,0.6);
  }
  50% {
    transform: scale(1.05);
    box-shadow: 0 12px 40px rgba(0,0,0,0.8);
  }
  100% {
    transform: scale(1);
    box-shadow: 0 8px 30px rgba(0,0,0,0.6);
  }
}

@keyframes bulbGlow {
  0% {
    transform: scale(1);
    filter: brightness(1);
  }
  50% {
    transform: scale(1.05);
    filter: brightness(1.2);
  }
  100% {
    transform: scale(1);
    filter: brightness(1);
  }
}

@keyframes wifiPulse {
  0% {
    opacity: 0.6;
    transform: scale(0.95);
  }
  50% {
    opacity: 1;
    transform: scale(1.05);
  }
  100% {
    opacity: 0.6;
    transform: scale(0.95);
  }
}

/* CSS Logo */
.mark-css {
  width: 52px;
  height: 52px;
  border-radius: 16px;
  background: linear-gradient(135deg, var(--accent1), var(--accent2));
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
  box-shadow: 0 8px 30px rgba(122,57,255,0.15);
  position: relative;
  animation: logoEntrance 1.2s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
  opacity: 0;
}

.logo-icon {
  position: relative;
  width: 32px;
  height: 32px;
}

.logo-circle {
  width: 24px;
  height: 24px;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.2);
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  border: 2px solid white;
  animation: logoEntrance 1.2s 0.1s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
  opacity: 0;
}

.logo-inner {
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background: white;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  opacity: 0;
  animation: logoEntrance 1.2s 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
}

.logo-wave {
  position: absolute;
  width: 32px;
  height: 32px;
  border-radius: 50%;
  border: 2px solid rgba(255, 255, 255, 0.7);
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  animation: wavePulse 2s infinite ease-out;
  opacity: 0;
  animation-delay: 0.6s;
  animation-fill-mode: forwards;
}

.logo-wave:nth-child(2) {
  animation-delay: 0.9s;
}

.logo-wave:nth-child(3) {
  animation-delay: 1.2s;
}

/* Cards */
.card{background:linear-gradient(180deg, rgba(255,255,255,0.014), rgba(255,255,255,0.008));border-radius:14px;padding:12px;border:1px solid var(--glass);backdrop-filter: blur(var(--blur));box-shadow:var(--soft-shadow);margin-bottom:12px}
.status-row{display:flex;justify-content:space-between;align-items:center;gap:10px}
.pres-left{display:flex;align-items:center;gap:8px}
.pres-dot{width:12px;height:12px;border-radius:50%;background:#2a2a42}
.pres-dot.on{background:#4ef0a0;box-shadow:0 6px 18px rgba(78,240,160,0.08)}
.small{font-size:13px;color:var(--muted2)}

/* Lights grid fixed 3-in-row */
.lights-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:14px;margin-top:12px;align-items:start}
.light-block{text-align:center;cursor:pointer}
.circle{width:86px;height:86px;border-radius:999px;margin:0 auto;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:6px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.06);transition:all .16s}
.circle:active{transform:translateY(-3px) scale(.98)}
.bulb{font-size:36px;transition:all .22s;animation: bulbGlow 3s infinite ease-in-out}
.inner-status{font-size:12px;font-weight:700;color:var(--muted2)}
.light-block.on .circle{background:linear-gradient(135deg,#fff2c2,#ffd17a);border:1px solid rgba(255,255,255,0.16);box-shadow:0 16px 60px rgba(255,200,100,0.12)}
.light-block.on .bulb{transform:scale(1.12);filter:brightness(1.55) saturate(1.4);text-shadow:0 8px 22px rgba(255,190,60,0.12);animation: bulbGlow 1.5s infinite ease-in-out}
.nameBelow{margin-top:8px;font-weight:600;color:var(--muted)}

/* last row center two */
.last-row{grid-column:1 / -1;display:flex;justify-content:space-around;gap:18px;padding-top:6px}

/* Modes top */
.modes-row{display:flex;gap:10px;margin-top:12px}
.mode{flex:1;padding:10px;border-radius:12px;background:rgba(255,255,255,0.02);text-align:center;cursor:pointer;transition:all .14s}
.mode:hover{transform:translateY(-4px)}
.mode.active{background:linear-gradient(90deg,var(--accent1),var(--accent2));color:#07213a;box-shadow:0 12px 30px rgba(122,57,255,0.08);font-weight:700}
.setup-btn{padding:8px 12px;border-radius:10px;background:linear-gradient(90deg,var(--accent1),var(--accent2));border:0;color:#07213a;cursor:pointer;font-weight:700;box-shadow:0 8px 30px rgba(125,150,255,0.06)}

/* bottom navbar */
#navbar{position:fixed;left:50%;transform:translateX(-50%);bottom:16px;width:94%;max-width:var(--max-width);z-index:9999}
.bottom-nav{display:flex;justify-content:space-between;align-items:center;padding:12px;border-radius:999px;background:linear-gradient(90deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.04);width:100%;box-shadow:0 8px 30px rgba(0,0,0,0.6);height:var(--nav-height);backdrop-filter: blur(12px);-webkit-backdrop-filter: blur(12px);}
.nav-item{flex:1;text-align:center;padding:6px 6px;border-radius:12px;color:var(--muted2);cursor:pointer;transition:all .14s}
.nav-item.active{color:#07213a;background:linear-gradient(90deg,var(--accent1),var(--accent2));box-shadow:0 12px 30px rgba(125,150,255,0.10)}

/* icons simple shapes */
.home-icon{width:22px;height:22px;display:block;margin:0 auto;position:relative}
.home-icon:before{content:"";position:absolute;left:50%;top:0;transform:translateX(-50%);width:0;height:0;border-left:12px solid transparent;border-right:12px solid transparent;border-bottom:12px solid rgba(255,255,255,0.95)}
.home-icon:after{content:"";position:absolute;left:50%;top:10px;transform:translateX(-50%);width:18px;height:12px;border:3px solid rgba(255,255,255,0.95);border-top:none;border-radius:3px}
.clock-icon{width:20px;height:20px;margin:0 auto;border:3px solid rgba(255,255,255,0.95);border-radius:50%;position:relative}
.clock-icon:after{content:"";position:absolute;left:50%;top:40%;transform:translate(-50%,-50%);width:2px;height:6px;background:rgba(255,255,255,0.95)}
.gear-icon{width:18px;height:18px;margin:0 auto;position:relative}
.gear-ring{width:10px;height:10px;border:3px solid rgba(255,255,255,0.95);border-radius:50%;position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);z-index:2}
.gear-tooth{position:absolute;width:4px;height:10px;background:rgba(255,255,255,0.95);border-radius:3px;left:50%;top:50%;transform-origin:center -6px}
.gear-tooth.t1{transform:translate(-50%,-50%) rotate(0deg)}.gear-tooth.t2{transform:translate(-50%,-50%) rotate(45deg)}.gear-tooth.t3{transform:translate(-50%,-50%) rotate(90deg)}.gear-tooth.t4{transform:translate(-50%,-50%) rotate(135deg)}.gear-tooth.t5{transform:translate(-50%,-50%) rotate(180deg)}.gear-tooth.t6{transform:translate(-50%,-50%) rotate(225deg)}.gear-tooth.t7{transform:translate(-50%,-50%) rotate(270deg)}.gear-tooth.t8{transform:translate(-50%,-50%) rotate(315deg)}

/* Modern Tab Icons */
.home-icon-modern {
  width: 24px;
  height: 24px;
  position: relative;
  margin: 0 auto;
}

.home-icon-modern:before {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  width: 0;
  height: 0;
  border-left: 12px solid transparent;
  border-right: 12px solid transparent;
  border-bottom: 10px solid rgba(255,255,255,0.95);
}

.home-icon-modern:after {
  content: "";
  position: absolute;
  top: 10px;
  left: 4px;
  width: 16px;
  height: 12px;
  background: rgba(255,255,255,0.95);
  border-radius: 2px;
}

.clock-icon-modern {
  width: 22px;
  height: 22px;
  margin: 0 auto;
  border: 2px solid rgba(255,255,255,0.95);
  border-radius: 50%;
  position: relative;
}

.clock-icon-modern:before {
  content: "";
  position: absolute;
  top: 50%;
  left: 50%;
  width: 2px;
  height: 6px;
  background: rgba(255,255,255,0.95);
  transform: translate(-50%, -50%);
}

.clock-icon-modern:after {
  content: "";
  position: absolute;
  top: 30%;
  left: 50%;
  width: 6px;
  height: 2px;
  background: rgba(255,255,255,0.95);
  transform: translate(-50%, -50%);
}

.gear-icon-modern {
  width: 24px;
  height: 24px;
  margin: 0 auto;
  position: relative;
}

.gear-icon-modern::before {
  content: '';
  position: absolute;
  width: 20px;
  height: 20px;
  border: 2px solid rgba(255,255,255,0.95);
  border-radius: 50%;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
}

.gear-icon-modern::after {
  content: '';
  position: absolute;
  width: 10px;
  height: 10px;
  border: 2px solid rgba(255,255,255,0.95);
  border-radius: 50%;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
}

.gear-icon-modern .gear-tooth {
  position: absolute;
  width: 3px;
  height: 6px;
  background: rgba(255,255,255,0.95);
  left: 50%;
  top: -3px;
  transform-origin: center 15px;
}

.gear-icon-modern .gear-tooth.t1 { transform: translate(-50%, -50%) rotate(0deg); }
.gear-icon-modern .gear-tooth.t2 { transform: translate(-50%, -50%) rotate(30deg); }
.gear-icon-modern .gear-tooth.t3 { transform: translate(-50%, -50%) rotate(60deg); }
.gear-icon-modern .gear-tooth.t4 { transform: translate(-50%, -50%) rotate(90deg); }
.gear-icon-modern .gear-tooth.t5 { transform: translate(-50%, -50%) rotate(120deg); }
.gear-icon-modern .gear-tooth.t6 { transform: translate(-50%, -50%) rotate(150deg); }
.gear-icon-modern .gear-tooth.t7 { transform: translate(-50%, -50%) rotate(180deg); }
.gear-icon-modern .gear-tooth.t8 { transform: translate(-50%, -50%) rotate(210deg); }
.gear-icon-modern .gear-tooth.t9 { transform: translate(-50%, -50%) rotate(240deg); }
.gear-icon-modern .gear-tooth.t10 { transform: translate(-50%, -50%) rotate(270deg); }
.gear-icon-modern .gear-tooth.t11 { transform: translate(-50%, -50%) rotate(300deg); }
.gear-icon-modern .gear-tooth.t12 { transform: translate(-50%, -50%) rotate(330deg); }

/* Centered modal styling + blur behind */
.modal-back{position:fixed;inset:0;align-items:center;justify-content:center;background:rgba(0,0,0,0.45);z-index:1200}
.modal{width:92%;max-width:520px;background:linear-gradient(180deg,#0f0720,#150926);border-radius:12px;padding:16px;border:1px solid rgba(255,255,255,0.06);box-shadow:0 30px 80px rgba(0,0,0,0.6);backdrop-filter: blur(6px);}

/* mode choices grid */
.mode-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:8px}
.mode-chip{padding:10px;border-radius:10px;background:rgba(255,255,255,0.02);cursor:pointer;text-align:center;color:var(--muted2);border:1px solid rgba(255,255,255,0.03)}
.mode-chip.selected{background:linear-gradient(90deg,var(--accent1),var(--accent2));color:#07213a}

/* Connected mode states */
.mode-chip.connected{background:linear-gradient(135deg, #4ef0a0, #2ed18a); color: #07213a; box-shadow: 0 0 15px rgba(78, 240, 160, 0.3);}



.mode-chip:hover {
  transform: translateY(-2px);
  box-shadow: 0 5px 15px rgba(0,0,0,0.3);
}

.mode-chip.selected {
  animation: modeSelectPulse 0.5s ease;
}

.mode-chip:active {
  transform: scale(0.95);
}







/* Notification Modal Slide Down Animation */
@keyframes slideDown {
  0% { transform: translateY(-100%); opacity: 0; }
  100% { transform: translateY(0); opacity: 1; }
}

.notification-modal-slide-down {
  animation: slideDown 0.3s ease-out forwards;
}

/* mode selection */
.mode-selection{padding:10px;border-radius:10px;background:rgba(255,255,255,0.02);cursor:pointer;text-align:center;color:var(--muted2);border:1px solid rgba(255,255,255,0.03);transition:all 0.2s ease}
.mode-selection:hover{background:rgba(255,255,255,0.06);transform:translateY(-2px)}

/* settings inner layout improvements (Rename + Tools kept in Settings) */
.settings-tabs{display:flex;gap:8px;margin-bottom:12px}
.settings-tab{padding:10px 12px;border-radius:999px;background:transparent;border:1px solid rgba(255,255,255,0.03);color:var(--muted2);cursor:pointer}
.settings-tab.active{background:linear-gradient(90deg,var(--accent1),var(--accent2));color:#07213a}
.rename-list{display:grid;grid-template-columns:1fr;gap:8px}
.rename-row{display:flex;gap:8px;align-items:center}
.rename-row input{flex:1;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--muted)}

/* tools actions 2 per row */
.tools-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px}
.tools-grid button{padding:10px;border-radius:10px;border:0;cursor:pointer;transition:all 0.3s ease;position:relative;overflow:hidden}
.tools-grid button:active{transform:scale(0.95)}
.tools-grid button:after{content:"";position:absolute;top:50%;left:50%;width:5px;height:5px;background:rgba(255,255,255,0.5);opacity:0;border-radius:100%;transform:scale(1,1) translate(-50%,-50%);transform-origin:50% 50%}
.tools-grid button.pressed:after{animation:ripple 0.6s ease-out}

/* Button animations */
.btn, .ghost, .setup-btn {
  position: relative;
  overflow: hidden;
  transition: all 0.3s ease;
}

.btn:active, .ghost:active, .setup-btn:active {
  transform: scale(0.95);
}

.btn:after, .ghost:after, .setup-btn:after {
  content: "";
  position: absolute;
  top: 50%;
  left: 50%;
  width: 5px;
  height: 5px;
  background: rgba(255,255,255,0.5);
  opacity: 0;
  border-radius: 100%;
  transform: scale(1,1) translate(-50%,-50%);
  transform-origin: 50% 50%;
}

.btn.pressed:after, .ghost.pressed:after, .setup-btn.pressed:after, .wifi-btn.pressed:after {
  animation: ripple 0.6s ease-out;
}

/* Theme-colored buttons */
.btn {
  background: linear-gradient(90deg, var(--accent1), var(--accent2));
  color: #07213a;
  font-weight: 700;
  border: none;
}

/* WiFi buttons */
.wifi-btn {
  position: relative;
  overflow: hidden;
  box-shadow: 0 8px 30px rgba(125,150,255,0.06);
}

.wifi-btn:after {
  content: "";
  display: block;
  position: absolute;
  width: 100%;
  height: 100%;
  top: 0;
  left: 0;
  background: radial-gradient(circle, rgba(255,255,255,0.4) 0%, transparent 70%);
  opacity: 0;
  pointer-events: none;
}

.ghost {
  background: rgba(255,255,255,0.06);
  border: 1px solid rgba(255,255,255,0.08);
  color: var(--muted);
}

.setup-btn {
  padding: 8px 12px;
  border-radius: 10px;
  background: linear-gradient(90deg, var(--accent1), var(--accent2));
  border: 0;
  color: #07213a;
  cursor: pointer;
  font-weight: 700;
  box-shadow: 0 8px 30px rgba(125,150,255,0.06);
}

/* Toggle switch */
.toggle {
  position: relative;
  display: inline-block;
  width: 60px;
  height: 30px;
}

.toggle input {
  opacity: 0;
  width: 0;
  height: 0;
}

.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #ccc;
  transition: .4s;
  border-radius: 34px;
}

.slider:before {
  position: absolute;
  content: "";
  height: 22px;
  width: 22px;
  left: 4px;
  bottom: 4px;
  background-color: white;
  transition: .4s;
  border-radius: 50%;
}

.toggle input:checked + .slider {
  background: linear-gradient(90deg, var(--accent1), var(--accent2));
}

.toggle input:checked + .slider:before {
  transform: translateX(30px);
}

/* logs improved */
.log-list{max-height:240px;overflow:auto;padding:0;margin:0;list-style:none}
.log-list li{padding:10px;border-bottom:1px solid rgba(255,255,255,0.03);font-size:13px;color:var(--muted2);line-height:1.35}

/* Blynk status */
#blynkStatus{font-weight:600}

#blynkDisconnectBtn{margin-left:8px}

@keyframes ripple {
  0% {transform:scale(0,0);opacity:1}
  100% {transform:scale(30,30);opacity:0}
}

/* Popup Notification */
.notification-popup {
  position: fixed;
  top: 20px;
  right: 20px;
  width: 320px;
  background: linear-gradient(180deg, rgba(255,255,255,0.014), rgba(255,255,255,0.008));
  border-radius: 14px;
  padding: 16px;
  border: 1px solid rgba(255,255,255,0.09);
  backdrop-filter: blur(8px);
  box-shadow: 0 10px 30px rgba(13,18,46,0.55);
  z-index: 10000;
  transform: translateX(120%);
  transition: transform 0.3s ease-out;
  cursor: pointer;
}

.notification-popup.show {
  transform: translateX(0);
}

.notification-popup-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
}

.notification-popup-title {
  font-weight: 600;
  font-size: 14px;
}

.notification-popup-close {
  background: none;
  border: none;
  color: var(--muted2);
  cursor: pointer;
  font-size: 16px;
}

.notification-popup-content {
  font-size: 13px;
  color: var(--muted);
}

.notification-popup-timestamp {
  font-size: 11px;
  color: var(--muted2);
  margin-top: 8px;
  text-align: right;
}

/* Mobile-like Notification Popup */
.mobile-notification {
  position: fixed;
  top: 20px;
  left: 50%;
  transform: translateX(-50%) translateY(-100%);
  width: 90%;
  max-width: 400px;
  background: linear-gradient(180deg, rgba(255,255,255,0.014), rgba(255,255,255,0.008));
  border-radius: 14px;
  padding: 16px;
  border: 1px solid rgba(255,255,255,0.09);
  backdrop-filter: blur(8px);
  box-shadow: 0 10px 30px rgba(13,18,46,0.55);
  z-index: 10000;
  transition: transform 0.3s ease-out;
  cursor: pointer;
}

.mobile-notification.show {
  transform: translateX(-50%) translateY(0);
}

.mobile-notification-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
}

.mobile-notification-title {
  font-weight: 600;
  font-size: 14px;
}

.mobile-notification-close {
  background: none;
  border: none;
  color: var(--muted2);
  cursor: pointer;
  font-size: 16px;
}

.mobile-notification-content {
  font-size: 13px;
  color: var(--muted);
}

.mobile-notification-timestamp {
  font-size: 11px;
  color: var(--muted2);
  margin-top: 8px;
  text-align: right;
}
</style>
</head>
<body>

<div id="main">

  <!-- Notification Container -->
  <div id="notificationContainer"></div>

  <!-- header -->
  <div class="header">
    <div class="brand">
      <div class="mark-css">
        <div class="logo-icon">
          <div class="logo-circle"></div>
          <div class="logo-inner"></div>
          <div class="logo-wave"></div>
          <div class="logo-wave"></div>
          <div class="logo-wave"></div>
        </div>
      </div>
      <div>
        <div class="brand-title">SmartSwitch</div>
        <div class="brand-sub">Classroom</div>
        <div class="brand-sub"><a href="https://demonaquarius.github.io/smartlight/" style="color: var(--muted2); text-decoration: none;">GitHub Page</a></div>
      </div>
    </div>

    <div style="display: flex; gap: 12px;">
      <div id="notificationBtn" class="wifi-btn" title="Notifications">
        <div style="width: 24px; height: 24px; display: flex; align-items: center; justify-content: center;">
          <div style="width: 16px; height: 16px; border: 2px solid white; border-radius: 50%; position: relative;">
            <div style="position: absolute; top: -4px; right: -4px; width: 8px; height: 8px; background: #4ef0a0; border-radius: 50%;"></div>
            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 2px; height: 2px; background: white; border-radius: 50%;"></div>
            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) rotate(45deg); width: 6px; height: 2px; background: white; border-radius: 1px;"></div>
          </div>
        </div>
      </div>

      <div id="wifiBtn" class="wifi-btn disconnected" title="Blynk Connection Status">
        <div class="wifi-arc wifi-a3"></div>
        <div class="wifi-arc wifi-a2"></div>
        <div class="wifi-arc wifi-a1"></div>
        <div class="wifi-dot"></div>
      </div>
    </div>
  </div>

  <!-- presence card -->
  <div class="card">
    <div class="status-row">
      <div class="pres-left">
        <div id="presDot" class="pres-dot"></div>
        <div>
          <div style="font-weight:700">Presence</div>
          <div id="presText" class="small">No one</div>
        </div>
      </div>

      <div id="connectionStatus" style="text-align:center;font-size:10px;color:var(--muted2)">Disconnected from Blynk</div>
      <div style="text-align:right">
        <div class="small">Last event</div>
        <div id="lastEvent" class="small">â€”</div>
      </div>
    </div>
  </div>

  <!-- HOME -->
  <div id="homePage">
    <div class="card">
      <div style="font-weight:700;margin-bottom:8px">Lights</div>
      <div id="lightsGrid" class="lights-grid"></div>
    </div>

    <div class="card">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div style="font-weight:700">Modes</div>
        <button id="openSetup" class="setup-btn">SETUP</button>
      </div>
      <div class="modes-row">
        <div id="modeTeaching" class="mode" data-mode="teaching">Teaching Mode</div>
        <div id="modeProjector" class="mode" data-mode="projector">Projector Mode</div>
        <div id="modeEnergy" class="mode" data-mode="energy">Energy Saver</div>
      </div>
    </div>
  </div>

  <!-- TIMER -->
  <div id="timerPage" style="display:none">
    <div class="card">
      <h3 style="margin:0 0 8px 0">Schedules</h3>
      <div style="display:flex;gap:8px;flex-wrap:wrap">
        <input id="schStart" class="input" type="time">
        <input id="schEnd" class="input" type="time">
        <select id="schScene" class="input" style="width:200px"><option value="teaching">Teaching</option><option value="projector">Projector</option><option value="energy">Energy Saver</option></select>
        <button id="addSchedule" class="btn">Add</button>
        <button id="clearSchedules" class="ghost">Clear</button>
      </div>
      <div id="scheduleList" style="margin-top:10px;max-height:160px;overflow:auto"></div>
    </div>

    <div class="card" style="margin-top:12px">
      <h3 style="margin:0 0 8px 0">Timers</h3>
      <div style="display:flex;gap:8px;flex-wrap:wrap">
        <input id="tHours" class="input" type="number" min="0" max="23" placeholder="Hours" style="width:110px">
        <input id="tMinutes" class="input" type="number" min="0" max="59" placeholder="Minutes" style="width:110px">
        <input id="tSeconds" class="input" type="number" min="0" max="59" placeholder="Seconds" style="width:110px">
        <select id="tLight" class="input" style="width:180px"></select>
        <button id="addTimer" class="btn">Add Timer</button>
        <button id="clearTimers" class="ghost">Clear</button>
      </div>
      <div id="timersList" style="margin-top:10px"></div>
    </div>
  </div>

  <!-- SETTINGS -->
  <div id="settingsPage" style="display:none">
    <div class="card">
      <div class="settings-tabs">
        <div class="settings-tab active" data-tab="tabSensors">Sensors</div>
        <div class="settings-tab" data-tab="tabRename">Rename Lights</div>
        <div class="settings-tab" data-tab="tabTools">Tools</div>
      </div>

      <div id="tabSensors">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px">
          <div style="display:flex;align-items:center;gap:12px">
            <div class="icon-circle">ðŸ‘¤</div>
            <div>
              <div style="font-weight:700">PIR Sensor</div>
              <div class="small">Motion trigger / Entry</div>
            </div>
          </div>
          <label class="toggle"><input id="pirToggle" type="checkbox"><span class="slider"></span></label>
        </div>

        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px">
          <div style="display:flex;align-items:center;gap:12px">
            <div class="icon-circle">ðŸ“¡</div>
            <div>
              <div style="font-weight:700">RCWL Radar</div>
              <div class="small">Microwave presence detection</div>
            </div>
          </div>
          <label class="toggle"><input id="rcwlToggle" type="checkbox"><span class="slider"></span></label>
        </div>

        <div style="display:flex;gap:8px;margin-top:12px;flex-wrap:wrap">
          <div style="flex:1" class="card">
            <div style="font-weight:700">PIR Settings</div>
            <div class="small" style="margin-top:8px">Delay (seconds)</div>
            <input id="pirDelay" class="input" type="number" min="0" placeholder="e.g. 10" />
          </div>

          <div style="flex:1" class="card">
            <div style="font-weight:700">RCWL Settings</div>
            <div class="small" style="margin-top:8px">Range (%)</div>
            <input id="rcwlRange" type="range" min="0" max="100" value="70" style="width:100%" />
            <div id="rcwlVal" class="small" style="margin-top:6px">70%</div>
          </div>
        </div>
      </div>

      <div id="tabRename" style="display:none">
        <h3 style="margin-top:0">Rename Lights</h3>
        <div id="renameList" class="rename-list" style="margin-top:8px"></div>
        <div style="display:flex;gap:8px;margin-top:10px">
          <button id="saveRename" class="btn">Save</button>
          <button id="resetNames" class="ghost">Reset Defaults</button>
        </div>
      </div>

      <div id="tabTools" style="display:none">
        <h3 style="margin-top:0">Tools & Quick Actions</h3>
        
        <!-- Blynk Integration Section -->
        <div class="card" style="margin-bottom:12px">
          <div style="font-weight:600;margin-bottom:8px">Blynk Integration</div>
          <div style="display:flex;flex-direction:column;gap:8px">
            <div style="display:flex;align-items:center;gap:8px">
              <input type="text" id="blynkTokenInput" placeholder="Enter Blynk Auth Token" style="flex:1;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--muted)">
              <button id="blynkConnectBtn" class="btn" style="padding:8px 12px">Connect</button>
              <button id="blynkDisconnectBtn" class="ghost" style="padding:8px 12px">Disconnect</button>
            </div>
            <div style="display:flex;align-items:center;gap:8px">
              <div class="small">Status:</div>
              <div id="blynkStatus" class="small" style="color:#ff9a9a">Not connected</div>
            </div>
            <div class="small" style="color:#7fb1ff">Predefined token for 'smartboard' template is automatically loaded</div>
          </div>
        </div>
        
        <div class="tools-grid" style="margin-top:8px">
          <button id="refreshBtn" class="btn">Refresh Device</button>
          <button id="restartBtn" class="ghost">Restart Device</button>
          <button id="clearLogsBtn" class="ghost">Clear Logs</button>
          <button id="exportConfigBtn" class="btn">Export Config</button>
        </div>

        <div class="card" style="margin-top:12px">
          <div style="font-weight:600;margin-bottom:8px">Logs (latest 10)</div>
          <ul id="logs" class="log-list"></ul>
        </div>
      </div>

    </div>
  </div>

</div> <!-- end main -->

<!-- bottom navbar -->
<div id="navbar">
  <div class="bottom-nav" role="navigation">
    <div class="nav-item active" data-page="home"><div class="home-icon-modern"></div><div style="margin-top:8px;font-size:13px">Home</div></div>
    <div class="nav-item" data-page="timer"><div class="clock-icon-modern"></div><div style="margin-top:8px;font-size:13px">Timer</div></div>
    <div class="nav-item" data-page="settings"><div class="gear-icon-modern"><div class="gear-tooth t1"></div><div class="gear-tooth t2"></div><div class="gear-tooth t3"></div><div class="gear-tooth t4"></div><div class="gear-tooth t5"></div><div class="gear-tooth t6"></div><div class="gear-tooth t7"></div><div class="gear-tooth t8"></div><div class="gear-tooth t9"></div><div class="gear-tooth t10"></div><div class="gear-tooth t11"></div><div class="gear-tooth t12"></div></div><div style="margin-top:8px;font-size:13px">Settings</div></div>
  </div>
</div>

<!-- Centered Mode Setup modal -->
<div id="modeModal" class="modal-back" style="display: none;">
  <div class="modal" role="dialog" aria-modal="true">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div style="font-weight:700" id="modeModalTitle">Mode Setup</div>
      <button id="closeMode" class="ghost">Close</button>
    </div>
    <div style="margin-top:12px" class="mode-grid" id="modeModalGrid"></div>
    <div style="display:flex;justify-content:flex-end;gap:8px;margin-top:12px">
      <button id="modeSaveBtn" class="btn">Save</button>
    </div>
  </div>
</div>

<!-- Blynk-only mode notification -->
<div id="wifiModal" class="modal-back" style="display: none;">
  <div class="modal">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div style="font-weight:700">Blynk-Only Mode</div>
      <div id="wifiStatusText" class="small">Device Controlled via Blynk Cloud</div>
    </div>

    <div style="margin-top:20px; text-align:center;">
      <p>This device operates in Blynk-only mode.</p>
      <p>All control is handled through the Blynk app.</p>
      <p>Connect to Blynk to control your SmartSwitch.</p>
    </div>

    <div style="display:flex;justify-content:center;margin-top:20px">
      <button id="closeWifi" class="ghost">Close</button>
    </div>
  </div>
</div>
<!-- Notification Modal -->
<div id="notificationModal" class="modal-back" style="align-items: flex-start; padding-top: 20px; display: none;">
  <div class="modal" style="height: 80vh; display: flex; flex-direction: column; margin-top: 0;">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div style="font-weight:700">Device Notifications</div>
      <button id="closeNotification" class="ghost">Close</button>
    </div>
    
    <div style="margin-top:16px; flex: 1; display: flex; flex-direction: column; overflow: hidden;">
      <div class="card" style="margin-bottom:12px; display: flex; justify-content: space-between; align-items: center;">
        <div style="font-weight:600;margin-bottom:8px">Connection Status</div>
        <div id="connectionStatusDetail" class="small">Disconnected</div>
      </div>
      
      <div class="card" style="margin-bottom:12px">
        <div style="font-weight:600;margin-bottom:8px">Sensor Status</div>
        <div class="small">PIR Sensor: <span id="pirStatus">Enabled</span></div>
        <div class="small">RCWL Radar: <span id="rcwlStatus">Enabled</span></div>
        <div class="small">Presence Detection: <span id="presenceStatus">No one detected</span></div>
      </div>
      
      <div class="card" style="margin-bottom:12px; display: flex; justify-content: space-between; align-items: center;">
        <div style="font-weight:600;margin-bottom:8px">Blynk</div>
        <div id="blynkIntegrationStatus" class="small">Not connected</div>
      </div>
      
      <div class="card" style="flex: 1; display: flex; flex-direction: column; overflow: hidden;">
        <div style="font-weight:600;margin-bottom:8px">Recent Events</div>
        <ul id="recentEvents" class="log-list" style="flex: 1; overflow-y: auto; max-height: 100%;"></ul>
      </div>
    </div>
  </div>
</div>


<script>
console.log('Script is loading...');
/* ---------- State & helpers ---------- */
const STORAGE = 'smart_ui_final_v1';

// Security module for token encryption
const SecurityModule = {
  // Simple encryption for client-side storage (not meant for high security, but better than plain text)
  encrypt: function(text, key) {
    if (!text) return '';
    try {
      const encoder = new TextEncoder();
      const data = encoder.encode(text);
      const keyData = encoder.encode(key);
      
      // Simple XOR encryption with key cycling
      let result = new Uint8Array(data.length);
      for (let i = 0; i < data.length; i++) {
        result[i] = data[i] ^ keyData[i % keyData.length];
      }
      
      // Convert to base64 for storage
      return btoa(String.fromCharCode(...result));
    } catch (e) {
      console.warn('Failed to encrypt token:', e.message);
      return '';
    }
  },
  
  decrypt: function(encryptedText, key) {
    if (!encryptedText) return '';
    try {
      const decoder = new TextDecoder();
      const data = new Uint8Array(atob(encryptedText).split('').map(c => c.charCodeAt(0)));
      const keyData = new TextEncoder().encode(key);
      
      // XOR decryption with key cycling
      let result = new Uint8Array(data.length);
      for (let i = 0; i < data.length; i++) {
        result[i] = data[i] ^ keyData[i % keyData.length];
      }
      
      return decoder.decode(result);
    } catch (e) {
      console.warn('Failed to decrypt token:', e.message);
      return '';
    }
  },
  
  // Generate a device-specific key based on browser fingerprint
  generateDeviceKey: function() {
    const fingerprint = [
      navigator.userAgent,
      navigator.language,
      screen.width,
      screen.height,
      new Date().getTimezoneOffset()
    ].join('|');
    
    // Simple hash function for key generation
    let hash = 0;
    for (let i = 0; i < fingerprint.length; i++) {
      const char = fingerprint.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32-bit integer
    }
    
    return 'key_' + Math.abs(hash).toString(36);
  }
};

function defaultState(){
  const names = ["Front Light","Board Light","Left Wall","Right Wall","Center 1","Center 2","Back Left","Back Right"];
  return {
    lights: names.map((n,i)=>({id:i,name:n,on:false,manual:false})),
    modeProjector: Array(8).fill(false),
    modeEnergy: Array(8).fill(false),
    presence:false,pir:true,rcwl:true,pirDelay:5,rcwlRange:70,
    schedules:[],timers:[],logs:[],wifiConnected:false
  };
}
let state = (()=>{ try{ const r = localStorage.getItem(STORAGE); return r? JSON.parse(r): defaultState(); }catch(e){ return defaultState(); } })();
function saveState(){ localStorage.setItem(STORAGE, JSON.stringify(state)); }
const $ = s => document.querySelector(s);
const $$ = s => Array.from(document.querySelectorAll(s));
function escapeHtml(s){ return String(s).replace(/[&<>"]/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

// API token management
let apiToken = '';

// Get API token from device
async function getApiToken() {
  try {
    const hosts = [];
    for (const h of hosts) {
      try {
        // Use https:// if page is loaded over HTTPS, otherwise http://
        const protocol = window.location.protocol === 'https:' ? 'https:' : 'http:';
        const url = `${protocol}//${h}/api/token`;
        
        // Include existing token in Authorization header if we have one
        const headers = {
          'Content-Type': 'application/json'
        };
        
        if (apiToken) {
          headers['Authorization'] = `Bearer ${apiToken}`;
        }
        
        const response = await fetch(url, { headers });
        if (response.ok) {
          const data = await response.json();
          apiToken = data.token;
          console.log('Got API token:', apiToken);
          return apiToken;
        }
      } catch(e) {
        console.warn(`Failed to get token from ${h}`, e);
      }
    }
  } catch(e) {
    console.warn('Failed to get API token', e);
  }
  return null;
}
function log(msg){ state.logs.unshift(new Date().toLocaleString() + ' â€” ' + msg); if(state.logs.length>800) state.logs.length=800; saveState(); renderLogs(true); 
  
  // Show popup notifications for important events
  const importantEvents = [
    'Connected to',
    'Disconnected',
    'Connection failed',
    'Device connected',
    'Device disconnected',
    'OTA update initiated',
    'Presence detected',
    'No presence detected',
    'Blynk connected',
    'Blynk disconnected'
  ];
  
  if (importantEvents.some(event => msg.includes(event))) {
    // Extract title from message
    let title = 'Notification';
    if (msg.includes('Connected to')) title = 'Connected';
    else if (msg.includes('Disconnected') || msg.includes('Connection failed')) title = 'Connection Issue';
    else if (msg.includes('Device connected')) title = 'Device Online';
    else if (msg.includes('Device disconnected')) title = 'Device Offline';
    else if (msg.includes('OTA update')) title = 'OTA Update';
    else if (msg.includes('Presence detected')) title = 'Presence Detected';
    else if (msg.includes('No presence detected')) title = 'No Presence';
    else if (msg.includes('Blynk connected')) title = 'Blynk Connected';
    else if (msg.includes('Blynk disconnected')) title = 'Blynk Disconnected';
    
    showPopupNotification(title, msg);
  }
}
function vibr(ms=6){ if(navigator.vibrate) navigator.vibrate(ms); }

/* ---------- Render functions ---------- */
function renderLights(){
  const grid = $('#lightsGrid'); grid.innerHTML='';
  state.lights.slice(0,6).forEach(l=>{
    const el = document.createElement('div'); el.className = 'light-block' + (l.on? ' on':'');
    el.innerHTML = `<div class="circle" data-id="${l.id}"><div class="bulb">ðŸ’¡</div><div class="inner-status">${l.on?'ON':'OFF'}</div></div><div class="nameBelow">${escapeHtml(l.name)}</div>`;
    el.querySelector('.circle').addEventListener('click', ()=>sendToggleWS(l.id));
    el.querySelector('.circle').addEventListener('contextmenu', e=>{ e.preventDefault(); renamePrompt(l.id); });
    grid.appendChild(el);
  });
  const lastRow = document.createElement('div'); lastRow.className='last-row';
  state.lights.slice(6).forEach(l=>{
    const el = document.createElement('div'); el.className = 'light-block' + (l.on? ' on':'');
    el.innerHTML = `<div class="circle" data-id="${l.id}"><div class="bulb">ðŸ’¡</div><div class="inner-status">${l.on?'ON':'OFF'}</div></div><div class="nameBelow">${escapeHtml(l.name)}</div>`;
    el.querySelector('.circle').addEventListener('click', ()=>sendToggleWS(l.id));
    el.querySelector('.circle').addEventListener('contextmenu', e=>{ e.preventDefault(); renamePrompt(l.id); });
    lastRow.appendChild(el);
  });
  grid.appendChild(lastRow);
  $('#presDot').classList.toggle('on', !!state.presence);
  $('#presText').textContent = state.presence ? 'Someone' : 'No one';
  saveState();
}

function toggleLight(id){
  // Use the ESP32 connector function instead of local state management
  sendToggleWS(id);
  
  // Also send to Blynk if connected
  if (blynkConnected) {
    const light = state.lights.find(l => l.id === id);
    if (light) {
      // Send to Blynk (assuming V0-V7 for 8 lights)
      sendToBlynk(`V${id}`, light.on ? 0 : 1); // Toggle state
    }
  }
}

function renamePrompt(id){
  const cur = state.lights.find(x=>x.id===id).name; const v = prompt('Rename light', cur);
  if(v!==null && v.trim()!==''){ state.lights[id].name = v.trim(); log(`Renamed light ${id+1} â†’ ${v.trim()}`); saveState(); renderLights(); renderRenameList(); populateTimerSelect(); }
}

/* Modes */
$('#modeTeaching').addEventListener('click', function() { 
  addButtonAnimation('modeTeaching');
  state.lights.forEach(l=> l.on = true); log('Teaching Mode applied (all ON)'); saveState(); renderLights(); 
  
  // Send to Blynk if connected
  if (blynkConnected) {
    updateBlynkModeIndicator('teaching');
    updateBlynkLightsState(); // Update individual lights
  }
});
$('#modeProjector').addEventListener('click', function() { 
  addButtonAnimation('modeProjector');
  applyMode('projector'); 
  
  // Send to Blynk if connected
  if (blynkConnected) {
    updateBlynkModeIndicator('projector');
    updateBlynkLightsState(); // Update individual lights
  }
});
$('#modeEnergy').addEventListener('click', function() { 
  addButtonAnimation('modeEnergy');
  applyMode('energy'); 
  
  // Send to Blynk if connected
  if (blynkConnected) {
    updateBlynkModeIndicator('energy');
    updateBlynkLightsState(); // Update individual lights
  }
});
function applyMode(mode){
  if(mode==='projector'){ state.lights.forEach((l,i)=> l.on = !!state.modeProjector[i]); log('Projector Mode applied'); }
  if(mode==='energy'){ state.lights.forEach((l,i)=> l.on = !!state.modeEnergy[i]); log('Energy Saver applied'); }
  saveState(); renderLights();
}

/* Mode setup modal center */
$('#openSetup').addEventListener('click', function() {
  addButtonAnimation('openSetup');
  openModeSelectionModal();
});

function openModeSelectionModal() {
  $('#modeModal').style.display = 'flex';
  $('#modeModalTitle').textContent = 'Select Mode to Setup';
  const grid = $('#modeModalGrid');
  grid.innerHTML = `
    <div class="mode-selection" data-mode="projector">
      <div class="mode-chip">Projector Mode</div>
    </div>
    <div class="mode-selection" data-mode="energy">
      <div class="mode-chip">Energy Saver</div>
    </div>
  `;
  
  // Add event listeners to mode selection
  $$('.mode-selection').forEach(el => {
    el.addEventListener('click', () => {
      const mode = el.dataset.mode;
      openModeModal(mode);
    });
  });
  
  document.body.style.overflow='hidden';
}
function openModeModal(mode){
  $('#modeModal').style.display = 'flex';
  $('#modeModalTitle').textContent = `Select lights for ${mode[0].toUpperCase()+mode.slice(1)} Mode`;
  $('#modeModal').dataset.mode = mode;
  const grid = $('#modeModalGrid'); grid.innerHTML = '';
  const arr = mode === 'projector' ? state.modeProjector : state.modeEnergy;
  state.lights.forEach((l,i)=>{
    const d = document.createElement('div'); d.className = 'mode-chip' + (arr[i] ? ' selected':'' ); d.textContent = l.name; d.dataset.i = i;
    d.addEventListener('click', ()=> d.classList.toggle('selected'));   
    grid.appendChild(d);
  });
  document.body.style.overflow='hidden';
}
$('#closeMode').addEventListener('click', function() { 
  addButtonAnimation('closeMode');
  $('#modeModal').style.display='none'; document.body.style.overflow=''; 
});
$('#modeSaveBtn').addEventListener('click', function() {
  addButtonAnimation('modeSaveBtn');
  const mode = $('#modeModal').dataset.mode || 'projector';
  const sel = Array.from($('#modeModalGrid').querySelectorAll('.mode-chip.selected')).map(x=>+x.dataset.i);
  if(mode==='projector') state.modeProjector = state.modeProjector.map((v,i)=> sel.includes(i));
  else state.modeEnergy = state.modeEnergy.map((v,i)=> sel.includes(i));
  log(`${mode} saved`); saveState(); $('#modeModal').style.display='none'; document.body.style.overflow='';
});

/* Schedules & Timers */
$('#addSchedule').addEventListener('click', function() {
  addButtonAnimation('addSchedule');
  const s = $('#schStart').value, e = $('#schEnd').value, sc = $('#schScene').value;
  showMobileNotification('Error', 'Pick start and end'); return;
  state.schedules.push({start:s,end:e,scene:sc}); saveState(); renderSchedules(); log('Schedule added '+s+'-'+e+' '+sc);
});
$('#clearSchedules').addEventListener('click', function() { 
  addButtonAnimation('clearSchedules');
  showMobileNotification('Confirm', 'Schedules cleared');
  state.schedules=[]; saveState(); renderSchedules(); log('Schedules cleared'); 
});
function renderSchedules(){ const out = $('#scheduleList'); out.innerHTML=''; state.schedules.forEach((s,i)=>{ const r = document.createElement('div'); r.style.padding='8px'; r.style.borderBottom='1px solid rgba(255,255,255,0.03)'; r.innerHTML = `<div style="display:flex;justify-content:space-between;align-items:center"><div><strong>${escapeHtml(s.start)}</strong> â†’ <strong>${escapeHtml(s.end)}</strong> â€¢ ${escapeHtml(s.scene)}</div><div><button data-del="${i}" class="ghost">Delete</button></div></div>`; out.appendChild(r); }); $$('[data-del]').forEach(b=> b.onclick = e=> { const i = +e.target.dataset.del; addButtonAnimation(e.target.id || 'deleteSchedule'); state.schedules.splice(i,1); saveState(); renderSchedules(); log('Schedule removed'); }); }

$('#addTimer').addEventListener('click', function() {
  addButtonAnimation('addTimer');
  const h = Math.max(0, parseInt($('#tHours').value||0)), m = Math.max(0, parseInt($('#tMinutes').value||0)), s = Math.max(0, parseInt($('#tSeconds').value||0)), lid = parseInt($('#tLight').value||0);
  showMobileNotification('Error', 'Set duration'); return;
  const name = state.lights[lid].name;
  state.timers.push({name,h,m,s,light:lid,created:Date.now()}); saveState(); renderTimers(); log(`Timer set: ${name} ${h}h ${m}m ${s}s`);
});
$('#clearTimers').addEventListener('click', function() { 
  addButtonAnimation('clearTimers');
  showMobileNotification('Confirm', 'Timers cleared');
  state.timers=[]; saveState(); renderTimers(); log('Cleared timers'); 
});
function renderTimers(){ const area = $('#timersList'); area.innerHTML=''; state.timers.forEach((t,i)=>{ const d = document.createElement('div'); d.className='card'; d.style.display='flex'; d.style.justifyContent='space-between'; d.style.alignItems='center'; d.style.marginBottom='8px'; d.innerHTML = `<div><strong>${escapeHtml(t.name)}</strong><div class="small">${t.h}h ${t.m}m ${t.s}s</div></div><div><button data-deltimer="${i}" class="ghost">Remove</button></div>`; area.appendChild(d); }); $$('[data-deltimer]').forEach(b=> b.onclick = e=> { const i=+e.target.dataset.deltimer; addButtonAnimation(e.target.id || 'deleteTimer'); state.timers.splice(i,1); saveState(); renderTimers(); log('Timer removed'); }); }

/* Sensors & Tools (kept in Settings) */
$('#pirToggle').addEventListener('change', e=>{ state.pir = !!e.target.checked; saveState(); log('PIR ' + (state.pir?'enabled':'disabled')); });
$('#rcwlToggle').addEventListener('change', e=>{ state.rcwl = !!e.target.checked; saveState(); log('RCWL ' + (state.rcwl?'enabled':'disabled')); });
$('#pirDelay').addEventListener('input', e=>{ state.pirDelay = parseInt(e.target.value) || 0; saveState(); });
$('#rcwlRange').addEventListener('input', e=>{ state.rcwlRange = parseInt(e.target.value); $('#rcwlVal').textContent = state.rcwlRange + '%'; saveState(); });

function addButtonAnimation(buttonId) {
  console.log('addButtonAnimation called for:', buttonId);
  const btn = $(`#${buttonId}`);
  if (btn) {
    btn.classList.add('pressed');
    setTimeout(() => btn.classList.remove('pressed'), 600);
  }
}


// Blynk event listeners
$('#blynkConnectBtn').addEventListener('click', function() {
  addButtonAnimation('blynkConnectBtn');
  const token = $('#blynkTokenInput').value.trim();
  const hardcodedToken = '4uYijCw6szawn3uskltxhM3Qr-U_Pgvg'; // Your Blynk auth token
  
  // Generate device-specific key for encryption
  const deviceKey = SecurityModule.generateDeviceKey();
  
  // Check if trying to change the hardcoded token
  const savedHardcodedToken = localStorage.getItem('blynkHardcodedToken');
  if (savedHardcodedToken === 'true' && token !== hardcodedToken) {
    showMobileNotification('Warning', 'You are overriding the predefined Blynk token.');
    // Clear the hardcoded flag
    localStorage.removeItem('blynkHardcodedToken');
  }
  
  if (token) {
    // Save token to localStorage with encryption
    const encryptedToken = SecurityModule.encrypt(token, deviceKey);
    localStorage.setItem('blynkToken', encryptedToken);
    // Set flag if this is the hardcoded token
    if (token === hardcodedToken) {
      localStorage.setItem('blynkHardcodedToken', 'true');
    }
    initBlynk(token);
  } else {
    showMobileNotification('Error', 'Please enter a Blynk Auth Token');
  }
});

function disconnectBlynk() {
  const hardcodedToken = '4uYijCw6szawn3uskltxhM3Qr-U_Pgvg'; // Your Blynk auth token
  
  // Generate device-specific key for decryption
  const deviceKey = SecurityModule.generateDeviceKey();
  
  // Decrypt the saved token for comparison
  const savedEncryptedToken = localStorage.getItem('blynkToken');
  const savedToken = savedEncryptedToken ? SecurityModule.decrypt(savedEncryptedToken, deviceKey) : '';
  
  // Don't clear the token if it's the hardcoded one
  if (savedToken === hardcodedToken) {
    // Just disconnect but keep the token
    if (blynkWebSocket) {
      // Clear intervals before closing
      if (blynkWebSocket.pingInterval) {
        clearInterval(blynkWebSocket.pingInterval);
      }
      if (blynkWebSocket.syncInterval) {
        clearInterval(blynkWebSocket.syncInterval);
      }
      blynkWebSocket.close();
      blynkWebSocket = null;
    }
    blynkConnected = false;
    blynkToken = '';
    document.getElementById('blynkStatus').textContent = 'Disconnected';
    document.getElementById('blynkStatus').style.color = '#ff9a9a';
    console.log('Disconnected from Blynk but kept hardcoded token');
  } else {
    // Clear everything
    if (blynkWebSocket) {
      // Clear intervals before closing
      if (blynkWebSocket.pingInterval) {
        clearInterval(blynkWebSocket.pingInterval);
      }
      if (blynkWebSocket.syncInterval) {
        clearInterval(blynkWebSocket.syncInterval);
      }
      blynkWebSocket.close();
      blynkWebSocket = null;
    }
    blynkConnected = false;
    blynkToken = '';
    localStorage.removeItem('blynkToken');
    localStorage.removeItem('blynkHardcodedToken');
    document.getElementById('blynkTokenInput').value = '';
    document.getElementById('blynkStatus').textContent = 'Disconnected';
    document.getElementById('blynkStatus').style.color = '#ff9a9a';
    console.log('Disconnected from Blynk and cleared token');
  }
}

$('#blynkDisconnectBtn').addEventListener('click', function() {
  addButtonAnimation('blynkDisconnectBtn');
  disconnectBlynk();
});

// Add disconnect button functionality if needed
// This could be added to the UI as well

/* Rename list UI inside settings (no modal) */
function renderRenameList(){ const wrap = $('#renameList'); wrap.innerHTML=''; state.lights.forEach(l=>{ const row = document.createElement('div'); row.className='rename-row'; row.innerHTML = `<div style="width:28px">${l.id+1}.</div><input data-rename="${l.id}" value="${escapeHtml(l.name)}">`; wrap.appendChild(row); }); }

// Add event listeners for rename functionality
function initRenameListeners() {
  const saveRenameBtn = $('#saveRename');
  const resetNamesBtn = $('#resetNames');
  
  if (saveRenameBtn) {
    saveRenameBtn.addEventListener('click', function(){ 
      addButtonAnimation('saveRename');
      $$('input[data-rename]').forEach(inp=>{ const id = +inp.dataset.rename; const v = inp.value.trim(); if(v) state.lights[id].name = v; }); saveState(); renderLights(); renderRenameList(); populateTimerSelect(); log('Saved light names'); 
    });
  }
  
  if (resetNamesBtn) {
    resetNamesBtn.addEventListener('click', function(){ 
      addButtonAnimation('resetNames');
      showMobileNotification('Confirm', 'Defaults reset'); state = defaultState(); saveState(); initUI(); log('Reset to defaults'); 
    });
  }
}

// Add event listeners for tools functionality
function initToolsListeners() {
  const refreshBtn = $('#refreshBtn');
  const restartBtn = $('#restartBtn');
  const clearLogsBtn = $('#clearLogsBtn');
  const exportConfigBtn = $('#exportConfigBtn');
  
  if (refreshBtn) {
    refreshBtn.addEventListener('click', function() {
      addButtonAnimation('refreshBtn');
      // In Blynk-only mode, we refresh by requesting state
      if (blynkConnected) {
        // Request state update from device via Blynk
        sendToBlynk('V12', 1); // Request device status
        showMobileNotification('Refresh', 'Device state refresh requested');
      } else {
        showMobileNotification('Error', 'Not connected to Blynk');
      }
    });
  }
  
  if (restartBtn) {
    restartBtn.addEventListener('click', function() {
      addButtonAnimation('restartBtn');
      if (blynkConnected) {
        // Send restart command via Blynk
        sendToBlynk('V21', 1); // Assuming V21 for restart command
        showMobileNotification('Restart', 'Device restart command sent');
      } else {
        showMobileNotification('Error', 'Not connected to Blynk');
      }
    });
  }
  
  if (clearLogsBtn) {
    clearLogsBtn.addEventListener('click', function() {
      addButtonAnimation('clearLogsBtn');
      state.logs = [];
      saveState();
      renderLogs();
      showMobileNotification('Logs', 'Logs cleared');
    });
  }
  
  if (exportConfigBtn) {
    exportConfigBtn.addEventListener('click', function() {
      addButtonAnimation('exportConfigBtn');
      // Export configuration as JSON
      const config = {
        lights: state.lights,
        pir: state.pir,
        rcwl: state.rcwl,
        pirDelay: state.pirDelay,
        rcwlRange: state.rcwlRange
      };
      const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(config, null, 2));
      const downloadAnchorNode = document.createElement('a');
      downloadAnchorNode.setAttribute("href", dataStr);
      downloadAnchorNode.setAttribute("download", "smartlight_config.json");
      document.body.appendChild(downloadAnchorNode);
      downloadAnchorNode.click();
      downloadAnchorNode.remove();
      showMobileNotification('Export', 'Configuration exported');
    });
  }
}

// Add event listeners for settings tabs
function initSettingsTabListeners() {
  // Set initial state - Sensors tab active by default
  const settingsTabs = $$('.settings-tab');
  settingsTabs.forEach(function(tab) {
    // Remove active class from all tabs initially
    tab.classList.remove('active');
    
    // Set Sensors tab as active by default
    if (tab.dataset.tab === 'tabSensors') {
      tab.classList.add('active');
    }
  });
  
  // Hide non-active tabs initially
  $('#tabRename').style.display = 'none';
  $('#tabTools').style.display = 'none';
  
  // Add event listeners for tab clicks
  settingsTabs.forEach(function(tab) {
    tab.addEventListener('click', function() {
      // Remove active class from all tabs
      settingsTabs.forEach(function(t) {
        t.classList.remove('active');
      });
      // Add active class to clicked tab
      tab.classList.add('active');
      
      // Hide all tab content
      $('#tabSensors').style.display = 'none';
      $('#tabRename').style.display = 'none';
      $('#tabTools').style.display = 'none';
      
      // Show the corresponding tab content
      const tabId = tab.dataset.tab;
      if (tabId === 'tabSensors') {
        $('#tabSensors').style.display = 'block';
      }
      else if (tabId === 'tabRename') {
        $('#tabRename').style.display = 'block';
      }
      else if (tabId === 'tabTools') {
        $('#tabTools').style.display = 'block';
      }
    });
  });
}

/* Logs render (latest 10) */
function renderLogs(autoScroll){ const ul = $('#logs'); ul.innerHTML=''; state.logs.slice(0,10).forEach(l=>{ const li = document.createElement('li'); li.textContent = l; ul.appendChild(li); }); if(autoScroll) { ul.scrollTop = 0; } }

// Initialize page navigation
function initPageNavigation() {
  // Add click event listeners to navigation items
  const navItems = document.querySelectorAll('.nav-item');
  navItems.forEach(item => {
    item.addEventListener('click', function() {
      const page = this.getAttribute('data-page');
      showPage(page);
    });
  });
  
  // Show home page by default
  showPage('home');
}

// Show specific page and hide others
function showPage(pageName) {
  // Hide all pages
  document.getElementById('homePage').style.display = 'none';
  document.getElementById('timerPage').style.display = 'none';
  document.getElementById('settingsPage').style.display = 'none';
  
  // Show the requested page
  document.getElementById(pageName + 'Page').style.display = 'block';
  
  // Update active nav item
  document.querySelectorAll('.nav-item').forEach(item => {
    item.classList.remove('active');
    if (item.getAttribute('data-page') === pageName) {
      item.classList.add('active');
    }
  });
}

// Load Blynk token on page load and initialize UI
console.log('About to add DOMContentLoaded listener');
document.addEventListener('DOMContentLoaded', function() {
  console.log('DOM Content Loaded');
  // Initialize UI first
  initUI();
  
  // Initialize page navigation
  initPageNavigation();
  
  // Add event listeners for notification and WiFi buttons
  /* Wi-Fi modal (center) - Blynk-only mode */
  const wifiBtn = $('#wifiBtn');
  console.log('Trying to attach event listener to wifiBtn:', wifiBtn);
  if (wifiBtn) {
    wifiBtn.addEventListener('click', function() { 
      console.log('WiFi button clicked');
      addButtonAnimation('wifiBtn');
      console.log('About to show wifiModal');
      $('#wifiModal').style.display='flex'; 
      document.body.style.overflow='hidden'; 
      console.log('wifiModal should be visible now');
    });
  } else {
    console.log('wifiBtn element not found!');
  }
  
  const notificationBtn = $('#notificationBtn');
  console.log('Trying to attach event listener to notificationBtn:', notificationBtn);
  if (notificationBtn) {
    notificationBtn.addEventListener('click', function() { 
      console.log('Notification button clicked');
      addButtonAnimation('notificationBtn');
      updateNotificationModal();
      console.log('About to show notificationModal');
      $('#notificationModal').style.display='flex'; document.body.style.overflow='hidden'; 
      console.log('Notification modal display set to flex');
      
      // Add slide down animation class
      const modal = $('#notificationModal .modal');
      if (modal) {
        modal.classList.add('notification-modal-slide-down');
      }
      
      // Start periodic updates while modal is open
      const notificationInterval = setInterval(updateNotificationModal, 2000);
      
      // Stop updates when modal is closed
      const stopUpdates = () => clearInterval(notificationInterval);
      
      // Store interval ID in a data attribute for later access
      $('#notificationModal').dataset.intervalId = notificationInterval;
    });
  }
  
  // Add event listener for close notification button
  const closeNotificationBtn = $('#closeNotification');
  if (closeNotificationBtn) {
    closeNotificationBtn.addEventListener('click', function() {
      console.log('Close notification button clicked');
      addButtonAnimation('closeNotification');
      
      // Stop updates
      const notificationModal = $('#notificationModal');
      if (notificationModal && notificationModal.dataset.intervalId) {
        clearInterval(parseInt(notificationModal.dataset.intervalId));
        delete notificationModal.dataset.intervalId;
      }
      
      // Close modal
      notificationModal.style.display='none';
      document.body.style.overflow='';
      
      // Remove animation class when closing
      const modal = $('#notificationModal .modal');
      if (modal) {
        modal.classList.remove('notification-modal-slide-down');
      }
    });
  }
  
  // Add event listener for clicking on modal backdrop
  const notificationModal = $('#notificationModal');
  if (notificationModal) {
    notificationModal.addEventListener('click', (e) => {
      if (e.target === notificationModal) {
        console.log('Notification modal backdrop clicked');
        
        // Stop updates
        if (notificationModal.dataset.intervalId) {
          clearInterval(parseInt(notificationModal.dataset.intervalId));
          delete notificationModal.dataset.intervalId;
        }
        
        // Close modal
        notificationModal.style.display='none';
        document.body.style.overflow='';
        
        // Remove animation class when closing
        const modal = $('#notificationModal .modal');
        if (modal) {
          modal.classList.remove('notification-modal-slide-down');
        }
      }
    });
  }
  
  const closeWifiBtn = $('#closeWifi');
  if (closeWifiBtn) {
    closeWifiBtn.addEventListener('click', function() { 
      addButtonAnimation('closeWifi');
      $('#wifiModal').style.display='none'; document.body.style.overflow=''; 
    });
  }
  
  const scanWifiBtn = $('#scanWifi');
  if (scanWifiBtn) {
    scanWifiBtn.addEventListener('click', function() {
      addButtonAnimation('scanWifi');
      // Removed demo WiFi scanning code
      // This will be handled by the ESP32 connector
    });
  }
});

// Blynk-only mode functionality
let currentMode = 'blynk'; // Only Blynk mode

// Initialize mode for Blynk-only
// Combined with main DOMContentLoaded handler above
// updateModeUI('BLYNK'); // Moved to after blynkConnected is initialized

// Simplified function to update UI for Blynk-only mode
function updateModeUI(mode) {
  // Update connection status display
  const wifiBtn = document.getElementById('wifiBtn');
  if (blynkConnected) {
    wifiBtn.classList.remove('disconnected');
    wifiBtn.classList.add('connected');
    document.getElementById('connectionStatus').textContent = 'Connected to Blynk';
  } else {
    wifiBtn.classList.remove('connected');
    wifiBtn.classList.add('disconnected');
    document.getElementById('connectionStatus').textContent = 'Disconnected from Blynk';
  }
}

// Simplified connection function for Blynk-only mode
async function tryConnectWebSocket() {
  // In Blynk-only mode, we don't connect directly to the device
  // All communication happens through Blynk
  console.log('Blynk-only mode: Direct device connection disabled');
  
  // Update UI to reflect Blynk-only mode
  const wifiBtn = document.getElementById('wifiBtn');
  if (blynkConnected) {
    wifiBtn.classList.remove('disconnected');
    wifiBtn.classList.add('connected');
    document.getElementById('connectionStatus').textContent = 'Connected to Blynk (Device controlled via cloud)';
  } else {
    wifiBtn.classList.remove('connected');
    wifiBtn.classList.add('disconnected');
    document.getElementById('connectionStatus').textContent = 'Connect to Blynk for device control';
  }
  
  return blynkConnected;
}

/* Nav switching */
$$('.nav-item').forEach(function(it) {
  it.addEventListener('click', function() {
    $$('.nav-item').forEach(function(x) {
      x.classList.remove('active');
    });
    it.classList.add('active');
    const p = it.dataset.page;
    $('#homePage').style.display = p==='home' ? 'block':'none';
    $('#timerPage').style.display = p==='timer' ? 'block':'none';
    $('#settingsPage').style.display = p==='settings' ? 'block':'none';
  });
  
  // Check URL parameters for token
  const urlParams = new URLSearchParams(window.location.search);
  const tokenFromUrl = urlParams.get('blynk_token');
  
  // Hardcoded token for your specific setup
  const hardcodedToken = '4uYijCw6szawn3uskltxhM3Qr-U_Pgvg';
  
  // Generate device-specific key for encryption
  const deviceKey = SecurityModule.generateDeviceKey();
  
  if (tokenFromUrl) {
    // Save token from URL and connect
    const encryptedToken = SecurityModule.encrypt(tokenFromUrl, deviceKey);
    localStorage.setItem('blynkToken', encryptedToken);
    document.getElementById('blynkTokenInput').value = tokenFromUrl;
    initBlynk(tokenFromUrl);
  } else {
    // Load saved token or use hardcoded token
    const savedEncryptedToken = localStorage.getItem('blynkToken');
    const isHardcoded = localStorage.getItem('blynkHardcodedToken') === 'true';
    
    if (savedEncryptedToken) {
      // Decrypt the token
      const savedToken = SecurityModule.decrypt(savedEncryptedToken, deviceKey);
      document.getElementById('blynkTokenInput').value = savedToken;
      // If we have a saved token that's not the hardcoded one, use it
      if (savedToken !== hardcodedToken || !isHardcoded) {
        initBlynk(savedToken);
      }
    } else if (hardcodedToken) {
      // Use hardcoded token as default
      const encryptedToken = SecurityModule.encrypt(hardcodedToken, deviceKey);
      document.getElementById('blynkTokenInput').value = hardcodedToken;
      localStorage.setItem('blynkToken', encryptedToken);
      localStorage.setItem('blynkHardcodedToken', 'true');
      console.log('Using hardcoded Blynk token for template: smartboard');
      // Auto-connect with hardcoded token after a short delay
      setTimeout(() => {
        initBlynk(hardcodedToken);
      }, 1000);
    }
  }
  
  // Periodically refresh API token
  setInterval(async () => {
    if (apiToken) {
      await getApiToken();
    }
  }, 1800000); // Refresh every 30 minutes
});


/* Populate timer select */
function populateTimerSelect(){ const sel = $('#tLight'); sel.innerHTML=''; state.lights.forEach(l=>{ const o = document.createElement('option'); o.value = l.id; o.textContent = l.name; sel.appendChild(o); }); }

/* close modals when clicking backdrop */
$$('.modal-back').forEach(m=> m.addEventListener('click', ev=> { if(ev.target === m){ addButtonAnimation(m.id || 'modalClose'); m.style.display='none'; document.body.style.overflow=''; } }));

/* ESC close */
document.addEventListener('keydown', e=> { if(e.key==='Escape'){ $$('.modal-back').forEach(m=> m.style.display='none'); document.body.style.overflow=''; } });

/* Init UI */
function initUI(){ console.log('initUI called'); renderLights(); renderRenameList(); renderSchedules(); renderTimers(); renderLogs(); populateTimerSelect(); if(state.wifiConnected) { $('#wifiBtn').classList.add('connected'); $('#wifiBtn').classList.remove('disconnected'); } else { $('#wifiBtn').classList.add('disconnected'); $('#wifiBtn').classList.remove('connected'); } $('#pirToggle').checked = !!state.pir; $('#rcwlToggle').checked = !!state.rcwl; $('#pirDelay').value = state.pirDelay; $('#rcwlRange').value = state.rcwlRange; $('#rcwlVal').textContent = state.rcwlRange + '%'; initRenameListeners(); initToolsListeners(); initSettingsTabListeners(); }

// Trigger logo animation on page load
window.addEventListener('DOMContentLoaded', function() {
  const logo = document.querySelector('.mark-css');
  if (logo) {
    // Animation is already handled by CSS
    // Just ensure elements are visible for the animation
    setTimeout(() => {
      const elements = logo.querySelectorAll('.logo-circle, .logo-inner, .logo-wave');
      elements.forEach(el => {
        el.style.opacity = '1';
      });
    }, 100);
  }
});

// Try to connect to the ESP32 device
// Add a longer delay to ensure the ESP32 has time to fully start up
setTimeout(() => {
  console.log('Attempting to connect to ESP32 device...');
  // First try to resolve the mDNS hostname to see if it's working
  checkMdnsResolution();
  tryConnectWebSocket();
}, 5000);

// Blynk initialization is now handled in the DOMContentLoaded event
// This timeout is no longer needed

// Function to check if mDNS resolution is working
async function checkMdnsResolution() {
  try {
    console.log('mDNS resolution checks disabled in Blynk-only mode');
    // Use https:// if page is loaded over HTTPS, otherwise http://
    const protocol = window.location.protocol === 'https:' ? 'https:' : 'http:';
    const response = await fetch('/api/wifi/status', {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json'
      }
    });
    if (response.ok) {
      console.log('mDNS resolution successful');
      document.getElementById('connectionStatus').textContent = 'mDNS resolution successful';
    } else {
      console.warn('mDNS resolution failed with status:', response.status);
      document.getElementById('connectionStatus').textContent = `mDNS resolution failed: ${response.status}`;
    }
  } catch (e) {
    console.warn('mDNS resolution failed with error:', e.message);
    document.getElementById('connectionStatus').textContent = `mDNS resolution error: ${e.message}`;
    // Provide user guidance
    if (e.message.includes('NAME_NOT_RESOLVED')) {
      console.log('Suggestion: Check if the device is powered on and connected to the same network');
    }
  }
}

/* SmartLight ESP connector â€” Blynk-only mode
   - All device communication happens through Blynk cloud
   - No local WiFi API or WebSocket connections
   - This script is designed for Blynk-only architecture
   
   Blynk Integration:
   - Template Name: smartboard
   - Auth Token: 4uYijCw6szawn3uskltxhM3Qr-U_Pgvg
   - V0-V7: Individual light control (V0 = Light 1, V1 = Light 2, etc.)
   - V10: Presence sensor status
   - V11: WiFi signal strength
   - V12: Device connection status
   - V13: Device name
   - V14: Firmware version
   - V20: Mode control (1=Teaching, 2=Projector, 3=Energy)
   
   Features:
   - Real-time control of lights and modes
   - Status synchronization
   - Notifications and emails
   - Bridge functionality for multiple devices
   - Property updates for widget labels
   - Hardware and app info reporting
   - Timezone and time synchronization
   - Location reporting (default)
*/

// Blynk integration
let blynkWebSocket = null;
let blynkConnected = false;
let blynkToken = '';

// Initialize mode UI after blynkConnected is defined
updateModeUI('BLYNK');

function initBlynk(token) {
  if (!token) return;
  
  blynkToken = token;
  const blynkServer = 'wss://blynk.cloud'; // Blynk WebSocket server
  const blynkUrl = `${blynkServer}/websocket/${token}`;
  
  // Close existing connection if any
  if (blynkWebSocket) {
    try {
      blynkWebSocket.close();
    } catch (e) {
      console.warn('Error closing existing Blynk connection:', e);
    }
  }
  
  try {
    console.log('Connecting to Blynk with token:', token.substring(0, 8) + '...');
    blynkWebSocket = new WebSocket(blynkUrl);
    
    blynkWebSocket.onopen = function(event) {
      console.log('Blynk WebSocket connected');
      blynkConnected = true;
      document.getElementById('blynkStatus').textContent = 'Connected to Blynk';
      document.getElementById('blynkStatus').style.color = '#4ef0a0';
      
      // Show popup notification
      showPopupNotification('Blynk Connected', 'Successfully connected to Blynk cloud service');
      
      // Check if this is the hardcoded token connection
      const hardcodedToken = '4uYijCw6szawn3uskltxhM3Qr-U_Pgvg';
      let showWelcome = false;
      if (blynkToken === hardcodedToken) {
        console.log('Successfully connected to Blynk with hardcoded token for template: smartboard');
        showWelcome = true;
      }
      
      // Send device information to Blynk
      setTimeout(() => {
        if (blynkConnected) {
          sendToBlynk('V13', 'SmartLight Controller'); // Device name
          sendToBlynk('V14', '1.0'); // Firmware version
          
          // Show welcome message for predefined token
          if (showWelcome) {
            sendBlynkNotification('Welcome!', 'Successfully connected to your SmartLight controller with Blynk template "smartboard"');
          }
        }
      }, 1000);
      
      // Send current state if device is connected
      if (socketReady) {
        sendToBlynk('V12', 1); // Device connected status
        updateBlynkLightsState(); // Light states
      }
      
      // Send ping to keep connection alive
      const pingInterval = setInterval(() => {
        if (blynkWebSocket && blynkWebSocket.readyState === WebSocket.OPEN) {
          blynkWebSocket.send('ping');
        }
      }, 30000);
      
      // Store interval ID so we can clear it later
      blynkWebSocket.pingInterval = pingInterval;
      
      // Periodic sync with Blynk (every 5 minutes)
      const syncInterval = setInterval(() => {
        if (blynkConnected) {
          // Send a sync request to get any updates from Blynk
          blynkWebSocket.send(JSON.stringify({type: 'sync'}));
        }
      }, 300000);
      
      // Store interval ID so we can clear it later
      blynkWebSocket.syncInterval = syncInterval;
      
      // Get API token for enhanced security
      getApiToken();
    };
    
    blynkWebSocket.onmessage = function(event) {
      console.log('Blynk message received:', event.data);
      handleBlynkMessage(event.data);
    };
    
    blynkWebSocket.onclose = function(event) {
      console.log('Blynk WebSocket closed');
      blynkConnected = false;
      document.getElementById('blynkStatus').textContent = 'Disconnected from Blynk';
      document.getElementById('blynkStatus').style.color = '#ff9a9a';
      
      // Show popup notification
      showPopupNotification('Blynk Disconnected', 'Lost connection to Blynk cloud service');
      
      // Clear intervals
      if (blynkWebSocket) {
        if (blynkWebSocket.pingInterval) {
          clearInterval(blynkWebSocket.pingInterval);
        }
        if (blynkWebSocket.syncInterval) {
          clearInterval(blynkWebSocket.syncInterval);
        }
      }
      
      // Try to reconnect after 5 seconds
      setTimeout(() => {
        if (blynkToken) {
          initBlynk(blynkToken);
        }
      }, 5000);
    };
    
    blynkWebSocket.onerror = function(error) {
      console.error('Blynk WebSocket error:', error);
      document.getElementById('blynkStatus').textContent = 'Blynk connection error';
      document.getElementById('blynkStatus').style.color = '#ff9a9a';
    };
  } catch (e) {
    console.error('Failed to initialize Blynk connection:', e);
    document.getElementById('blynkStatus').textContent = 'Blynk initialization failed';
    document.getElementById('blynkStatus').style.color = '#ff9a9a';
  }
}

function handleBlynkMessage(data) {
  try {
    const message = JSON.parse(data);
    
    if (message.type === 'write') {
      // Handle write commands from Blynk app
      const pin = message.pin;
      const value = message.value;
      
      // Handle specific pins
      if (pin.startsWith('V')) {
        const pinNumber = parseInt(pin.substring(1));
        
        // V0-V7: Control individual lights
        if (pinNumber >= 0 && pinNumber <= 7) {
          // Forward to local device if connected
          if (socket && socket.readyState === WebSocket.OPEN) {
            socket.send(JSON.stringify({
              cmd: 'toggle',
              id: pinNumber,
              state: value == 1 ? true : false
            }));
          }
        }
        
        // V10: Presence control
        else if (pinNumber === 10) {
          // Could implement presence override if needed
        }
        
        // V20: Mode control
        else if (pinNumber === 20) {
          switch (parseInt(value)) {
            case 1: // Teaching mode
              state.lights.forEach(l => l.on = true);
              saveState();
              renderLights();
              break;
            case 2: // Projector mode
              applyMode('projector');
              break;
            case 3: // Energy mode
              applyMode('energy');
              break;
          }
        }
      }
      
      // Forward to local device if connected
      if (socket && socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({
          cmd: 'blynkWrite',
          pin: pin,
          value: value
        }));
      }
    }
    
    // Handle sync requests from Blynk
    else if (message.type === 'sync') {
      // Send current state to Blynk
      updateBlynkLightsState();
      
      // Send current mode
      const currentMode = state.lights.every(l => l.on) ? 'teaching' : 
                         state.modeProjector.some((on, i) => on && state.lights[i].on) ? 'projector' : 
                         'energy';
      updateBlynkModeIndicator(currentMode);
      
      // Send presence status
      sendToBlynk('V10', state.presence ? 1 : 0);
      
      // Send device connection status
      sendToBlynk('V12', socketReady ? 1 : 0);
    }
    
    // Handle hardware info requests
    else if (message.type === 'hardwareInfo') {
      if (blynkWebSocket && blynkWebSocket.readyState === WebSocket.OPEN) {
        const info = {
          type: 'hardwareInfo',
          board: 'Web Browser',
          cpu: navigator.hardwareConcurrency ? `${navigator.hardwareConcurrency} cores` : 'Unknown',
          version: '1.0.0',
          profile: 'SmartLight Controller'
        };
        blynkWebSocket.send(JSON.stringify(info));
      }
    }
    
    // Handle app info requests
    else if (message.type === 'appInfo') {
      if (blynkWebSocket && blynkWebSocket.readyState === WebSocket.OPEN) {
        const info = {
          type: 'appInfo',
          name: 'SmartLight Web Controller',
          version: '1.0.0',
          platform: navigator.platform,
          userAgent: navigator.userAgent
        };
        blynkWebSocket.send(JSON.stringify(info));
      }
    }
    
    // Handle time requests
    else if (message.type === 'time') {
      if (blynkWebSocket && blynkWebSocket.readyState === WebSocket.OPEN) {
        const timeInfo = {
          type: 'time',
          tzName: Intl.DateTimeFormat().resolvedOptions().timeZone,
          tzOffset: new Date().getTimezoneOffset(),
          time: Date.now()
        };
        blynkWebSocket.send(JSON.stringify(timeInfo));
      }
    }
    
    // Handle location requests
    else if (message.type === 'location') {
      // We don't have location access in this context, but we can send a default location
      if (blynkWebSocket && blynkWebSocket.readyState === WebSocket.OPEN) {
        const locationInfo = {
          type: 'location',
          lat: 0.0,
          lon: 0.0,
          hae: 0.0,
          ver: 0.0,
          latExit: 0.0,
          lonExit: 0.0,
          haeExit: 0.0
        };
        blynkWebSocket.send(JSON.stringify(locationInfo));
      }
    }
    
    // Handle redirect requests
    else if (message.type === 'redirect') {
      // Handle Blynk server redirect if needed
      console.log('Blynk redirect requested to:', message.server);
      // In a real implementation, you might want to reconnect to the new server
      // For now, we'll just log it
    }
    
    // Handle disconnect requests
    else if (message.type === 'disconnect') {
      // Handle Blynk disconnect request
      console.log('Blynk disconnect requested');
      disconnectBlynk();
    }
    
    // Handle ping responses
    else if (message.type === 'pong') {
      // Handle Blynk ping response
      console.log('Blynk pong received');
      // Could be used for latency monitoring
    }
    
    // Handle internal messages
    else if (message.type === 'internal') {
      // Handle Blynk internal messages
      console.log('Blynk internal message:', message.data);
      // Could be used for debugging or special commands
    }
    
    // Handle JSON messages
    else if (message.type === 'json') {
      // Handle Blynk JSON messages
      try {
        const jsonData = JSON.parse(message.data);
        console.log('Blynk JSON message:', jsonData);
        // Could be used for complex data structures
      } catch (e) {
        console.warn('Failed to parse Blynk JSON message:', e);
      }
    }
    
    // Handle string messages
    else if (message.type === 'string') {
      // Handle Blynk string messages
      console.log('Blynk string message:', message.data);
      // Could be used for simple text commands
    }
    
    // Handle integer messages
    else if (message.type === 'int') {
      // Handle Blynk integer messages
      console.log('Blynk integer message:', message.data);
      // Could be used for numeric commands
    }
    
    // Handle double messages
    else if (message.type === 'double') {
      // Handle Blynk double messages
      console.log('Blynk double message:', message.data);
      // Could be used for floating point commands
    }
    
    // Handle array messages
    else if (message.type === 'array') {
      // Handle Blynk array messages
      console.log('Blynk array message:', message.data);
      // Could be used for multiple values
    }
    
    // Handle CSV messages
    else if (message.type === 'csv') {
      // Handle Blynk CSV messages
      console.log('Blynk CSV message:', message.data);
      // Could be used for tabular data
    }
    
    // Handle binary messages
    else if (message.type === 'binary') {
      // Handle Blynk binary messages
      console.log('Blynk binary message received, length:', message.data?.length || 0);
      // Could be used for image data, firmware updates, etc.
    }
    
    // Handle unknown messages
    else {
      // Handle unknown Blynk messages
      console.warn('Unknown Blynk message type:', message.type, message);
      // Log for debugging purposes
    }
  } catch (e) {
    console.warn('Failed to parse Blynk message:', e);
  }
}

function sendToBlynk(pin, value) {
  if (blynkWebSocket && blynkWebSocket.readyState === WebSocket.OPEN) {
    const message = {
      type: 'write',
      pin: pin,
      value: value
    };
    blynkWebSocket.send(JSON.stringify(message));
  }
}

function sendBlynkNotification(title, message) {
  if (blynkWebSocket && blynkWebSocket.readyState === WebSocket.OPEN) {
    const notification = {
      type: 'notify',
      title: title,
      message: message
    };
    blynkWebSocket.send(JSON.stringify(notification));
  }
}

function sendBlynkEmail(subject, message) {
  if (blynkWebSocket && blynkWebSocket.readyState === WebSocket.OPEN) {
    const email = {
      type: 'email',
      subject: subject,
      message: message
    };
    blynkWebSocket.send(JSON.stringify(email));
  }
}

function sendBlynkBridgeMessage(bridgePin, pin, value) {
  if (blynkWebSocket && blynkWebSocket.readyState === WebSocket.OPEN) {
    const message = {
      type: 'bridge',
      bridgePin: bridgePin,
      pin: pin,
      value: value
    };
    blynkWebSocket.send(JSON.stringify(message));
  }
}

// Blynk property functions
function setBlynkProperty(pin, property, value) {
  if (blynkWebSocket && blynkWebSocket.readyState === WebSocket.OPEN) {
    const message = {
      type: 'property',
      pin: pin,
      property: property,
      value: value
    };
    blynkWebSocket.send(JSON.stringify(message));
  }
}

function updateBlynkLightsState() {
  // Send light states to Blynk
  state.lights.forEach((light, index) => {
    // Assuming virtual pins V0-V7 for 8 lights
    sendToBlynk(`V${index}`, light.on ? 1 : 0);
    
    // Update widget labels
    setBlynkProperty(`V${index}`, 'label', light.name);
  });
}

function updateBlynkModeIndicator(mode) {
  // Update mode indicator on Blynk app
  let modeValue = 0;
  switch(mode) {
    case 'teaching': modeValue = 1; break;
    case 'projector': modeValue = 2; break;
    case 'energy': modeValue = 3; break;
  }
  sendToBlynk('V20', modeValue);
  
  // Update mode label
  const modeNames = {teaching: 'Teaching Mode', projector: 'Projector Mode', energy: 'Energy Saver'};
  setBlynkProperty('V20', 'label', modeNames[mode] || 'Unknown Mode');
}

// In Blynk-only mode, we don't use mDNS hosts

// current socket
let socket = null;
let socketReady = false;
let lastTried = [];

// In Blynk-only mode, we don't attempt local WebSocket connections
function tryWsHost(host, timeout=5000) {
  console.log('Local WebSocket connections disabled in Blynk-only mode');
  return Promise.resolve({ok:false, error: 'Local WebSocket connections disabled in Blynk-only mode'});

      // Use wss:// if page is loaded over HTTPS, otherwise ws://
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const url = `${protocol}//${host}/ws`;
      const ws = new WebSocket(url);
      let done = false;
      const tidy = (ok, error) => { 
        if(done) return; 
        done=true; 
        console.debug('WebSocket connection result for', host, ok ? 'SUCCESS' : 'FAILED', error || '');
        if(ok) resolve({ok:true, ws}); else resolve({ok:false, error});
      };
      ws.onopen = () => {
        console.debug('WebSocket opened to', host);
        tidy(true);
      };
      ws.onerror = (e) => {
        console.warn('WebSocket error for', host, e);
        // Provide more detailed error messages
        let errorMsg = 'Connection error';
        if (e.message && e.message.includes('insecure')) {
          errorMsg = 'Security error: Cannot connect to insecure WebSocket from secure page. Make sure your device supports WSS.';
        }
        tidy(false, errorMsg);
      };
      ws.onclose = (e) => { 
        if(!done) {
          console.debug('WebSocket closed for', host, e.code, e.reason);
          // Provide more user-friendly close messages
          let closeMsg = `Connection closed (${e.code})`;
          if (e.code === 1006) {
            closeMsg = 'Connection failed: Device may be offline or unreachable';
          } else if (e.code === 1011) {
            closeMsg = 'Server error: Device encountered an unexpected condition';
          }
          tidy(false, closeMsg);
        }
      };
      setTimeout(()=> tidy(false, 'Connection timeout'), timeout);
}

// In Blynk-only mode, we don't attempt local connections
async function tryConnectWebSocket() {
  // Update UI to show Blynk-only mode
  const wifiBtn = document.getElementById('wifiBtn');
  wifiBtn.classList.remove('connecting');
  wifiBtn.classList.add('disconnected');
  document.getElementById('wifiStatusText').textContent = 'Blynk-only Mode';
  document.getElementById('connectionStatus').textContent = 'Device controlled via Blynk cloud';







  // Show the Blynk-only mode modal
  $('#wifiModal').style.display = 'flex';
  document.body.style.overflow = 'hidden';
  
  console.log('Blynk-only mode: No local connection attempts made');
  
  return false;
      

  
  // Retry connection periodically if not connected
  setTimeout(() => {
    if (!socketReady) {
      tryConnectWebSocket();
    }
  }, 15000);
  
  return false;
}

function useSocket(ws, host) {
  if (socket) {
    try { socket.close(); } catch(e){}
  }
  socket = ws;
  socketReady = true;
  console.log('WebSocket connected to', host);
  
  // Add visual feedback for connection
  const wifiBtn = document.getElementById('wifiBtn');
  wifiBtn.classList.remove('disconnected', 'connecting');
  wifiBtn.classList.add('connected');
  document.getElementById('wifiStatusText').textContent = `Connected to ${host}`;
  document.getElementById('connectionStatus').textContent = `Connected to ${host}`;
  
  // Update mode button connected states based on current mode
  updateModeConnectedState(currentMode.toUpperCase(), true);
        
  // Show popup notification
  showPopupNotification('Device Connected', `SmartLight connected to ${host}`);
  
  // Send notification to Blynk
  if (blynkConnected) {
    sendBlynkNotification('Device Connected', `SmartLight connected to ${host}`);
  }
  
  socket.onmessage = (ev) => handleWsMessage(ev.data);
  socket.onclose = () => { 
    socketReady = false; 
    console.log('WS closed'); 
    
    // Update UI to show disconnection
    const wifiBtn = document.getElementById('wifiBtn');
    wifiBtn.classList.remove('connected');
    wifiBtn.classList.add('disconnected');
    document.getElementById('wifiStatusText').textContent = 'Disconnected';
    document.getElementById('connectionStatus').textContent = 'Disconnected';
    
    // Update mode button connected states
    updateModeConnectedState(currentMode.toUpperCase(), false);
          
    // Show popup notification
    showPopupNotification('Device Disconnected', 'SmartLight device disconnected');
    
    // Send notification to Blynk
    if (blynkConnected) {
      sendBlynkNotification('Device Disconnected', 'SmartLight device disconnected');
    }
    
    setTimeout(()=> tryConnectWebSocket(), 1000); 
  };
  socket.onerror = (e) => { 
    socketReady = false; 
    console.warn('WS error', e); 
    
    // Update UI to show error
    const wifiBtn = document.getElementById('wifiBtn');
    wifiBtn.classList.remove('connected');
    wifiBtn.classList.add('disconnected');
    document.getElementById('wifiStatusText').textContent = 'Connection error';
    document.getElementById('connectionStatus').textContent = 'Connection error';
    
    // Update mode button connected states
    updateModeConnectedState(currentMode.toUpperCase(), false);
  };
  // request state
  setTimeout(()=> {
    try { 
      socket.send(JSON.stringify({cmd:'getState'})); 
      
      // Notify Blynk that device is connected
      if (blynkConnected) {
        sendToBlynk('V12', 1); // Device connected status
      }
    } catch(e){}
  }, 1000);
  
  // Periodically check connection status
  setInterval(() => {
    if (socket && socket.readyState === WebSocket.OPEN) {
      // Connection is good
      document.getElementById('wifiBtn').classList.add('connected');
      document.getElementById('wifiBtn').classList.remove('disconnected');
      
      // Notify Blynk that device is still connected
      if (blynkConnected) {
        sendToBlynk('V12', 1); // Device connected status
      }
    } else {
      // Connection lost
      document.getElementById('wifiBtn').classList.remove('connected');
      document.getElementById('wifiBtn').classList.add('disconnected');
      
      // Notify Blynk that device is disconnected
      if (blynkConnected) {
        sendToBlynk('V12', 0); // Device disconnected status
      }
      
      // Try to reconnect
      tryConnectWebSocket();
    }
  }, 30000); // Check every 30 seconds
}

function handleWsMessage(raw) {
  try {
    const d = JSON.parse(raw);
    
    // Update connection status display
    if (d.deviceInfo) {
      document.getElementById('connectionStatus').textContent = 
        `Device: ${d.deviceInfo.name || 'SmartLight'} (${d.deviceInfo.ip || 'Unknown'})`;
    }
    
    // update UI (lights)
    if (Array.isArray(d.lights)) {
      d.lights.forEach(l => {
        const id = l.id;
        const circle = document.querySelector(`.circle[data-id="${id}"]`);
        if (circle) {
          const parent = circle.closest('.light-block');
          if (l.on) parent.classList.add('on'); else parent.classList.remove('on');
          const inner = circle.querySelector('.inner-status');
          if (inner) inner.textContent = l.on ? 'ON' : 'OFF';
          const nameEl = parent.querySelector('.nameBelow');
          if (nameEl && nameEl.textContent !== l.name) nameEl.textContent = l.name;
          // also update local state store
          const ls = state.lights.find(x => x.id === id);
          if (ls) { ls.on = !!l.on; ls.name = l.name; ls.manual = !!l.manual; }
        }
      });
      
      // Update Blynk with new light states
      if (blynkConnected) {
        updateBlynkLightsState();
      }
    }
    
    if (typeof d.presence !== 'undefined') {
      const previousPresence = state.presence;
      document.getElementById('presDot').classList.toggle('on', !!d.presence);
      document.getElementById('presText').textContent = d.presence ? 'Someone' : 'No one';
      state.presence = !!d.presence;
      saveState();
      
      // Show popup notification for presence changes
      if (previousPresence !== state.presence) {
        if (state.presence) {
          showPopupNotification('Presence Detected', 'Motion or presence detected in the room');
        } else {
          showPopupNotification('No Presence', 'No motion or presence detected in the room');
        }
      }
      
      // Send presence status to Blynk (V10)
      if (blynkConnected) {
        sendToBlynk('V10', d.presence ? 1 : 0);
      }
    }
    
    if (typeof d.pirEnabled !== 'undefined') { 
      document.getElementById('pirToggle').checked = !!d.pirEnabled; 
      state.pir = !!d.pirEnabled; 
      saveState(); 
    }
    
    if (typeof d.rcwlEnabled !== 'undefined') { 
      document.getElementById('rcwlToggle').checked = !!d.rcwlEnabled; 
      state.rcwl = !!d.rcwlEnabled; 
      saveState(); 
    }
    
    // Handle device status updates
    if (d.status) {
      if (d.status.uptime) {
        // Could display uptime information if needed
      }
      
      if (d.status.signalStrength !== undefined) {
        // Could display WiFi signal strength
        // Send signal strength to Blynk (V11)
        if (blynkConnected) {
          sendToBlynk('V11', d.status.signalStrength);
        }
      }
    }
    
    // Handle Blynk commands from device
    if (d.blynkCmd) {
      if (blynkConnected) {
        sendToBlynk(d.blynkCmd.pin, d.blynkCmd.value);
      }
    }
    
    // logs and other values can be mapped similarly
  } catch(e) {
    console.warn('Invalid WS message', e);
  }
}

// Function to update notification modal with current status
function updateNotificationModal() {
  console.log('updateNotificationModal called');
  // Update connection status
  const connectionStatusElement = document.getElementById('connectionStatusDetail');
  if (blynkConnected) {
    connectionStatusElement.textContent = 'Connected to Blynk';
    connectionStatusElement.style.color = '#4ef0a0';
  } else {
    connectionStatusElement.textContent = 'Disconnected from Blynk';
    connectionStatusElement.style.color = '#ff9a9a';
  }
  
  // Update sensor status
  document.getElementById('pirStatus').textContent = state.pir ? 'Enabled' : 'Disabled';
  document.getElementById('rcwlStatus').textContent = state.rcwl ? 'Enabled' : 'Disabled';
  document.getElementById('presenceStatus').textContent = state.presence ? 'Someone detected' : 'No one detected';
  
  // Update Blynk integration status
  const blynkStatusElement = document.getElementById('blynkIntegrationStatus');
  if (blynkConnected) {
    blynkStatusElement.textContent = 'Connected';
    blynkStatusElement.style.color = '#4ef0a0';
  } else {
    blynkStatusElement.textContent = 'Not connected';
    blynkStatusElement.style.color = '#ff9a9a';
  }
  
  // Update recent events
  const recentEventsElement = document.getElementById('recentEvents');
  recentEventsElement.innerHTML = '';
  
  // Show last 10 log entries
  const recentLogs = state.logs.slice(0, 10);
  recentLogs.forEach(logEntry => {
    const li = document.createElement('li');
    li.className = 'log-entry';
    li.textContent = logEntry;
    recentEventsElement.appendChild(li);
  });
}

// In Blynk-only mode, we don't attempt local fetch requests
async function tryFetchAny(path, opts) {
  console.log('Local fetch requests disabled in Blynk-only mode');
  return null;
}

// Public helper used by UI code: send toggle using Blynk only
function sendToggleWS(id) {
  // In Blynk-only mode, we only send commands via Blynk
  if (blynkConnected) {
    // Send command via Blynk virtual pin
    sendToBlynk(`V${id}`, '1');
  } else {
    console.warn('Cannot send toggle command: Blynk not connected');
  }
}

// Function to show popup notification
function showPopupNotification(title, message, type = 'info') {
  // Create notification element
  const notification = document.createElement('div');
  notification.className = 'notification-popup';
  
  // Get current timestamp
  const now = new Date();
  const timestamp = now.toLocaleTimeString();
  
  // Set notification content
  notification.innerHTML = `
    <div class="notification-popup-header">
      <div class="notification-popup-title">${title}</div>
      <button class="notification-popup-close">Ã—</button>
    </div>
    <div class="notification-popup-content">${message}</div>
    <div class="notification-popup-timestamp">${timestamp}</div>
  `;
  
  // Add to notification container
  const container = document.getElementById('notificationContainer');
  container.appendChild(notification);
  
  // Show notification with animation
  setTimeout(() => {
    notification.classList.add('show');
  }, 10);
  
  // Auto hide after 5 seconds
  setTimeout(() => {
    hidePopupNotification(notification);
  }, 5000);
  
  // Add close button functionality
  const closeButton = notification.querySelector('.notification-popup-close');
  closeButton.addEventListener('click', (e) => {
    e.stopPropagation();
    hidePopupNotification(notification);
  });
  
  // Close when clicked anywhere on the notification
  notification.addEventListener('click', () => {
    hidePopupNotification(notification);
  });
  
  // Log the notification
  log(`${title}: ${message}`);
}

// Function to hide popup notification
function hidePopupNotification(notification) {
  notification.classList.remove('show');
  setTimeout(() => {
    if (notification.parentNode) {
      notification.parentNode.removeChild(notification);
    }
  }, 300);
}

// Function to show mobile-like notification at the bottom
function showMobileNotification(title, message) {
  // Create notification element
  const notification = document.createElement('div');
  notification.className = 'mobile-notification';
  
  // Get current timestamp
  const now = new Date();
  const timestamp = now.toLocaleTimeString();
  
  // Set notification content
  notification.innerHTML = `
    <div class="mobile-notification-header">
      <div class="mobile-notification-title">${title}</div>
      <button class="mobile-notification-close">Ã—</button>
    </div>
    <div class="mobile-notification-content">${message.replace(/\n/g, '<br>')}</div>
    <div class="mobile-notification-timestamp">${timestamp}</div>
  `;
  
  // Add to notification container
  const container = document.getElementById('notificationContainer');
  container.appendChild(notification);
  
  // Show notification with animation
  setTimeout(() => {
    notification.classList.add('show');
  }, 10);
  
  // Auto hide after 5 seconds
  setTimeout(() => {
    hideMobileNotification(notification);
  }, 5000);
  
  // Add close button functionality
  const closeButton = notification.querySelector('.mobile-notification-close');
  closeButton.addEventListener('click', (e) => {
    e.stopPropagation();
    hideMobileNotification(notification);
  });
  
  // Close when clicked anywhere on the notification
  notification.addEventListener('click', () => {
    hideMobileNotification(notification);
  });
  
  // Log the notification
  log(`${title}: ${message}`);
}

// Function to hide mobile notification
function hideMobileNotification(notification) {
  notification.classList.remove('show');
  setTimeout(() => {
    if (notification.parentNode) {
      notification.parentNode.removeChild(notification);
    }
  }, 300);
}

// Test popup notification (remove this in production)
// showPopupNotification('Test Notification', 'This is a test popup notification');

// Enhanced log function that also shows popup notifications for important events
function enhancedLog(message, showPopup = false, title = 'Notification') {
  log(message);
  
  if (showPopup) {
    showPopupNotification(title, message);
  }
}
</script>
</body>
</html>
